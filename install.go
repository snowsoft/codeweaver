// Universal installer for Code Weaver
// Build: go build -o install-weaver install.go
// Run: ./install-weaver (or install-weaver.exe on Windows)

package main

import (
    "bufio"
    "fmt"
    "io"
    "net/http"
    "os"
    "os/exec"
    "path/filepath"
    "runtime"
    "strings"
)

const (
    repoURL = "https://github.com/snowsoft/codeweaver"
    configExample = `# Weaver Configuration File
# This file is automatically generated

# Ollama API Configuration
ollama:
  api_url: "http://localhost:11434"
  model: "codellama:13b-instruct"
  temperature: 0.7
  max_tokens: 4096
  timeout: 120s

# UI Configuration
ui:
  theme: "dark"
  show_spinner: true
  diff_colors:
    added: "green"
    removed: "red"
    modified: "yellow"

# Default Settings
defaults:
  context_depth: 3
  auto_backup: true
  backup_dir: ".weaver_backups"

# Language-specific settings
languages:
  python:
    test_framework: "pytest"
    doc_style: "google"
  javascript:
    test_framework: "jest"
    doc_style: "jsdoc"
  go:
    test_framework: "testing"
    doc_style: "godoc"
  php:
    test_framework: "phpunit"
    doc_style: "phpdoc"
`
)

func main() {
    fmt.Println("===============================================")
    fmt.Println("  Code Weaver Universal Installer")
    fmt.Printf("  OS: %s/%s\n", runtime.GOOS, runtime.GOARCH)
    fmt.Println("===============================================")
    fmt.Println()

    // Check prerequisites
    if !checkGo() {
        return
    }

    if !checkOllama() {
        return
    }

    // Installation options
    fmt.Println("Choose installation method:")
    fmt.Println("1. Download pre-built binary (recommended)")
    fmt.Println("2. Build from source")
    fmt.Println("3. Setup only (if already installed)")
    fmt.Print("\nEnter choice (1-3): ")

    reader := bufio.NewReader(os.Stdin)
    choice, _ := reader.ReadString('\n')
    choice = strings.TrimSpace(choice)

    switch choice {
    case "1":
        installPrebuilt()
    case "2":
        buildFromSource()
    case "3":
        setupOnly()
    default:
        fmt.Println("Invalid choice")
        return
    }

    // Setup configuration
    setupConfig()

    fmt.Println("\n‚úÖ Installation complete!")
    fmt.Println("\nNext steps:")
    fmt.Println("1. Make sure Ollama is running: ollama serve")
    fmt.Println("2. Pull a model: ollama pull codellama:13b-instruct")
    fmt.Println("3. Test Weaver: weaver --help")
}

func checkGo() bool {
    fmt.Print("Checking Go installation... ")
    
    cmd := exec.Command("go", "version")
    output, err := cmd.Output()
    if err != nil {
        fmt.Println("‚ùå Not found")
        fmt.Println("\nGo is required for building from source.")
        fmt.Println("Download from: https://go.dev/dl/")
        return false
    }
    
    fmt.Printf("‚úÖ %s", output)
    return true
}

func checkOllama() bool {
    fmt.Print("Checking Ollama installation... ")
    
    // Try to connect to Ollama API
    resp, err := http.Get("http://localhost:11434/api/tags")
    if err != nil {
        fmt.Println("‚ö†Ô∏è  Not running")
        fmt.Println("\nOllama is required for Code Weaver to function.")
        fmt.Println("Install from: https://ollama.ai/download")
        fmt.Println("\nContinuing with installation anyway...")
        return true
    }
    defer resp.Body.Close()
    
    if resp.StatusCode == 200 {
        fmt.Println("‚úÖ Running")
    } else {
        fmt.Println("‚ö†Ô∏è  Not accessible")
    }
    
    return true
}

func installPrebuilt() {
    fmt.Println("\nüì• Downloading pre-built binary...")
    
    // Determine binary name
    binaryName := "weaver"
    if runtime.GOOS == "windows" {
        binaryName = "weaver.exe"
    }
    
    // Construct download URL
    downloadURL := fmt.Sprintf("%s/releases/latest/download/weaver-%s-%s",
        repoURL, runtime.GOOS, runtime.GOARCH)
    if runtime.GOOS == "windows" {
        downloadURL += ".exe"
    }
    
    fmt.Printf("Download URL: %s\n", downloadURL)
    
    // Download binary
    resp, err := http.Get(downloadURL)
    if err != nil || resp.StatusCode != 200 {
        fmt.Println("‚ùå Failed to download binary")
        fmt.Println("Pre-built binaries may not be available yet.")
        fmt.Println("Please choose 'Build from source' option instead.")
        return
    }
    defer resp.Body.Close()
    
    // Save binary
    out, err := os.Create(binaryName)
    if err != nil {
        fmt.Printf("‚ùå Failed to create file: %v\n", err)
        return
    }
    defer out.Close()
    
    _, err = io.Copy(out, resp.Body)
    if err != nil {
        fmt.Printf("‚ùå Failed to save file: %v\n", err)
        return
    }
    
    // Make executable on Unix
    if runtime.GOOS != "windows" {
        os.Chmod(binaryName, 0755)
    }
    
    fmt.Println("‚úÖ Binary downloaded successfully")
    
    // Install to system
    installBinary(binaryName)
}

func buildFromSource() {
    fmt.Println("\nüî® Building from source...")
    
    // Check if in project directory
    if _, err := os.Stat("go.mod"); os.IsNotExist(err) {
        // Clone repository
        fmt.Println("Cloning repository...")
        cmd := exec.Command("git", "clone", repoURL)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil {
            fmt.Printf("‚ùå Failed to clone repository: %v\n", err)
            return
        }
        
        // Change to project directory
        os.Chdir("codeweaver")
    }
    
    // Install dependencies
    fmt.Println("\nInstalling dependencies...")
    cmd := exec.Command("go", "mod", "download")
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.Run()
    
    // Tidy
    cmd = exec.Command("go", "mod", "tidy")
    cmd.Run()
    
    // Build
    fmt.Println("\nBuilding...")
    binaryName := "weaver"
    if runtime.GOOS == "windows" {
        binaryName = "weaver.exe"
    }
    
    cmd = exec.Command("go", "build", "-o", binaryName, ".")
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil {
        fmt.Printf("‚ùå Build failed: %v\n", err)
        return
    }
    
    fmt.Println("‚úÖ Build successful")
    
    // Install to system
    installBinary(binaryName)
}

func installBinary(binaryName string) {
    fmt.Println("\nüìÅ Installing to system...")
    
    var installPath string
    
    switch runtime.GOOS {
    case "windows":
        // Options for Windows
        fmt.Println("\nInstall location:")
        fmt.Println("1. User directory (recommended)")
        fmt.Println("2. System directory (requires admin)")
        fmt.Println("3. Current directory")
        fmt.Print("\nChoice (1-3): ")
        
        reader := bufio.NewReader(os.Stdin)
        choice, _ := reader.ReadString('\n')
        choice = strings.TrimSpace(choice)
        
        switch choice {
        case "1":
            userBin := filepath.Join(os.Getenv("USERPROFILE"), ".local", "bin")
            os.MkdirAll(userBin, 0755)
            installPath = filepath.Join(userBin, binaryName)
            
            // Add to PATH instruction
            fmt.Printf("\n‚ö†Ô∏è  Add %s to your PATH environment variable\n", userBin)
        case "2":
            installPath = filepath.Join(os.Getenv("SYSTEMROOT"), "System32", binaryName)
        default:
            fmt.Println("‚úÖ Binary available in current directory")
            return
        }
        
    case "darwin", "linux":
        // Unix-like systems
        fmt.Println("\nInstall location:")
        fmt.Println("1. /usr/local/bin (recommended, requires sudo)")
        fmt.Println("2. ~/.local/bin (user only)")
        fmt.Println("3. Current directory")
        fmt.Print("\nChoice (1-3): ")
        
        reader := bufio.NewReader(os.Stdin)
        choice, _ := reader.ReadString('\n')
        choice = strings.TrimSpace(choice)
        
        switch choice {
        case "1":
            installPath = "/usr/local/bin/weaver"
        case "2":
            userBin := filepath.Join(os.Getenv("HOME"), ".local", "bin")
            os.MkdirAll(userBin, 0755)
            installPath = filepath.Join(userBin, "weaver")
        default:
            fmt.Println("‚úÖ Binary available in current directory")
            return
        }
    }
    
    // Copy binary
    if installPath != "" {
        if strings.Contains(installPath, "System32") || strings.HasPrefix(installPath, "/usr") {
            // Need elevated permissions
            fmt.Println("\n‚ö†Ô∏è  Administrator/sudo access required")
            
            if runtime.GOOS == "windows" {
                cmd := exec.Command("cmd", "/c", "copy", binaryName, installPath)
                cmd.Run()
            } else {
                cmd := exec.Command("sudo", "cp", binaryName, installPath)
                cmd.Stdin = os.Stdin
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                cmd.Run()
            }
        } else {
            // Regular copy
            input, _ := os.ReadFile(binaryName)
            err := os.WriteFile(installPath, input, 0755)
            if err != nil {
                fmt.Printf("‚ùå Failed to install: %v\n", err)
                return
            }
        }
        
        fmt.Printf("‚úÖ Installed to: %s\n", installPath)
    }
}

func setupOnly() {
    fmt.Println("\n‚öôÔ∏è  Setting up configuration only...")
}

func setupConfig() {
    fmt.Println("\nüìù Setting up configuration...")
    
    // Determine config directory
    var configDir string
    switch runtime.GOOS {
    case "windows":
        configDir = filepath.Join(os.Getenv("USERPROFILE"), ".config", "weaver")
    default:
        configDir = filepath.Join(os.Getenv("HOME"), ".config", "weaver")
    }
    
    // Create directory
    err := os.MkdirAll(configDir, 0755)
    if err != nil {
        fmt.Printf("‚ùå Failed to create config directory: %v\n", err)
        return
    }
    
    // Create config file if not exists
    configFile := filepath.Join(configDir, "config.yaml")
    if _, err := os.Stat(configFile); os.IsNotExist(err) {
        err = os.WriteFile(configFile, []byte(configExample), 0644)
        if err != nil {
            fmt.Printf("‚ùå Failed to create config file: %v\n", err)
            return
        }
        fmt.Printf("‚úÖ Config file created: %s\n", configFile)
    } else {
        fmt.Println("‚úÖ Config file already exists")
    }
}